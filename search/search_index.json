{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AIplay","text":"<p>Explore some of my projects:</p> Screen Project LeRobot Quadruped Pomodo Pomodo with case"},{"location":"about/","title":"About This Site","text":"<p>This little site is a collection of side projects I\u2019ve built during spare moments \u2014 some are for entry-level educational purposes, others are simply driven by curiosity. There\u2019s no grand plan here, but I do intend to keep moving... somewhere. Not necessarily forward, because frankly, there's no clear direction \u2014 just a desire to see where things might lead and what fun discoveries we might uncover along the way.</p> <p>If I were to loosely sketch a plan, it might look like this: start with simple things like blinking LEDs or tiny desk lights, and gradually escalate toward something more... cinematic \u2014 maybe even \u201cTerminator\u201d-grade tech. I\u2019m not promising we\u2019ll ever get there, but I\u2019m pretty sure the journey will be worth it.</p> <p></p>"},{"location":"contact/","title":"Contact","text":"<p>You can reach me at:</p> <ul> <li>GitHub: MiaoReynolds</li> <li>Email: support@aionelab.com</li> </ul>"},{"location":"extras-contact/","title":"Contact","text":"<p>We welcome contributions, feedback, and collaboration:</p> <ul> <li>Maintainer: Miao</li> <li>GitHub: yourusername</li> <li>Email: yourname@example.com</li> </ul>"},{"location":"extras-faq/","title":"FAQ","text":"<p>Q: Why is my servo vibrating randomly? A: It could be power instability. Try using a 5V 2A power source.</p> <p>Q: The camera doesn't stream. A: Double-check WiFi credentials and pin assignments.</p>"},{"location":"hardware/","title":"Hardware Overview","text":"<ul> <li>6 DOF servo motors</li> <li>ESP32 microcontroller board</li> <li>Power supply module (USB or battery)</li> <li>Optional: OLED display, camera module, joystick, buttons</li> </ul>"},{"location":"software/","title":"Software Architecture","text":"<ul> <li>Control scripts written in Arduino or MicroPython</li> <li>Master-follower arm logic</li> <li>UART and I2C communication for peripheral expansion</li> <li>Video feedback via ESP32-CAM module</li> </ul>"},{"location":"tutorial-advanced-topics/","title":"Tutorial advanced topics","text":""},{"location":"tutorial-advanced-topics/#tutorialsadvanced-topicsmd","title":"<code>tutorials/advanced-topics.md</code>","text":"<p>```markdown</p>"},{"location":"tutorial-advanced-topics/#advanced-applications","title":"Advanced Applications","text":"<ul> <li>Voice-controlled movement using AI voice modules</li> <li>ROS2 integration for trajectory planning</li> <li>Web interface control via WiFi</li> <li>Camera-based object tracking</li> </ul>"},{"location":"tutorial-control-basics/","title":"Basic Controls","text":"<p>This tutorial walks through simple position commands for the robotic arm:</p> <p>```cpp moveJoint(1, 90);  // Rotate joint 1 to 90 degrees</p>"},{"location":"tutorials-setup/","title":"Setup &amp; Wiring","text":"<ol> <li>Assemble the arm following the mechanical guide</li> <li>Connect servos to the controller board</li> <li>Flash the firmware using Arduino IDE or PlatformIO</li> <li>Power the system and test communication</li> </ol>"},{"location":"videos/","title":"Videos","text":"<p>Here are links to YouTube videos documenting each project:</p> Project Video Link AI Course (coming soon) Smart Display Device (coming soon) LeRobot Arm (coming soon) Quadruped (coming soon)"},{"location":"projects/ai-course/","title":"AI Course","text":"<p>This course includes:</p> Module Content Basics What is AI, History, Trends Tools Python, Colab, GPT, etc. Examples Prompts, use-cases"},{"location":"projects/lerobot/","title":"LeRobot Arm","text":"<p>Robotic education platform project:</p> Aspect Details Control Master-slave logic, ESP32 control Application Teaching, interactive demos"},{"location":"projects/quadruped/","title":"Quadruped Robot","text":"<p>An experimental AI-assisted walking robot:</p> Module Description Locomotion 4-legged servo structure Brain Microcontroller + IMU Goals Stability, gait learning"},{"location":"projects/quadruped/#gallery","title":"Gallery","text":"Initial Frame Walking Test AI Gait Control"},{"location":"projects/screen-project/","title":"Smart Display Device","text":"<p>A compact hardware device with:</p> Feature Details Screen OLED 1.3'' Brain ESP32 or similar Features Clock, AI message, visual animations"},{"location":"projects/ai-course/coding/","title":"AI Coding Tools","text":"<p>Hands-on with GPT, Copilot, etc.</p>"},{"location":"projects/ai-course/overview/","title":"AI Course Overview","text":"<p>Overview of the full AI curriculum.</p>"},{"location":"projects/ai-course/prompting/","title":"Prompt Engineering","text":"<p>Learn prompt design for LLMs.</p>"},{"location":"projects/lerobot/control/","title":"Control Logic","text":"<p>Master-follower control implementation.</p>"},{"location":"projects/lerobot/setup/","title":"Setup","text":"<p>How to connect servos and calibrate the arm.</p>"},{"location":"projects/lerobot/usecases/","title":"Use Cases","text":"<p>Educational, demo, and extension examples.</p>"},{"location":"projects/quadruped/ai/","title":"AI Integration","text":"<p>Sensors, IMU, and decision logic.</p>"},{"location":"projects/quadruped/frame/","title":"Mechanical Frame","text":"<p>Design of the 4-legged body.</p>"},{"location":"projects/quadruped/motion/","title":"Motion Algorithms","text":"<p>Gait planning and stabilization.</p>"},{"location":"projects/screen-project/build/","title":"Build Steps","text":"<p>Wiring, casing, and assembly guide.</p>"},{"location":"projects/screen-project/cloud-terminal/","title":"Cloud Terminal","text":"<p>Displays messages from cloud-based AI model (via Wi-Fi).</p>"},{"location":"projects/screen-project/code/","title":"Firmware Code","text":"<p>How the display is programmed.</p>"},{"location":"projects/screen-project/design/","title":"Hardware Design","text":"<p>Circuit and component overview.</p>"},{"location":"projects/screen-project/generative-graphics/","title":"Generative Graphics","text":"<p>Fun animated patterns using math + microcontroller graphics.</p>"},{"location":"projects/screen-project/pomodo_timer_V4/","title":"Pomodoro Timer Project","text":"<p>This project showcases a simple yet effective Pomodoro timer built with an ESP32 and an integrated 1.3 OLED display with knob and buttons. It can be used for more interesting projects as well</p>"},{"location":"projects/screen-project/pomodo_timer_V4/#hardware-components","title":"\ud83e\uddf0 Hardware Components","text":"<ul> <li>A 1.3-inch SH1106 OLED display connected via I2C (SDA=GPIO19, SCL=GPIO23)</li> <li>An EC11 rotary encoder (A=GPIO5, B=GPIO17, Push=GPIO18)</li> <li>A Confirm button on GPIO22 (functions the same as the rotary push button)</li> <li>A Back button on GPIO16 (used to exit countdown and return to main menu)</li> </ul> <p>GPT Prompt for the Code: Generate Arduino C++ code for an ESP32-based Pomodoro timer using the following hardware setup:</p> <ul> <li>A 1.3-inch SH1106 OLED display connected via I2C (SDA=GPIO19, SCL=GPIO23)</li> <li>An EC11 rotary encoder (A=GPIO5, B=GPIO17, Push=GPIO18)</li> <li>A Confirm button on GPIO22 (functions the same as the rotary push button)</li> <li>A Back button on GPIO16 (used to exit countdown and return to main menu)</li> </ul> <p>Requirements: 1. Display a scrollable menu of five options: \"Pomodoro 10 min\", \"Pomodoro 15 min\", \"Pomodoro 20 min\", \"Pomodoro 25 min\", and \"Info\". 2. Show 4 menu items on screen at a time, and highlight the currently selected one. 3. Use the rotary encoder to scroll through the menu, and use either the rotary push button or the Confirm button to start a Pomodoro countdown. 4. During countdown, display the remaining time in mm:ss format in large centered digits. 5. Pressing the Back button at any time during the countdown returns to the main menu. 6. Selecting \"Info\" displays author information for 3 seconds before returning to the menu. 7. Do not include any buzzer or sound feedback. 8. Use the U8g2 library and appropriate fonts for the OLED screen.</p>"},{"location":"projects/screen-project/pomodo_timer_V4/#key-code-snippet","title":"\ud83e\udde0 Key Code Snippet","text":"Click to expand full code <pre><code>#include &lt;U8g2lib.h&gt;\n#include &lt;Wire.h&gt;\n// Screen\uff08SH1106 OLED\uff09\n#define OLED_SDA 19\n#define OLED_SCL 23\n// EC11 encoder\n#define ROTARY_A     5\n#define ROTARY_B     17\n#define ROTARY_PUSH  18\n// button\n#define BTN_CONFIRM  22\n#define BTN_BACK     16\n// buzzer\n#define BUZZER_PIN   21  \n// manu\nconst int menuCount = 5;\nconst char* menuItems[menuCount] = {\n  \"Pomodoro 10 min\",\n  \"Pomodoro 15 min\",\n  \"Pomodoro 20 min\",\n  \"Pomodoro 25 min\",\n  \"Info\"\n};\n// variable status\nint menuIndex = 1;\nint lastCLK = HIGH;\nbool inCountdown = false;\nU8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);\n// ====== SETUP ======\nvoid setup() {\n  pinMode(ROTARY_A, INPUT_PULLUP);\n  pinMode(ROTARY_B, INPUT_PULLUP);\n  pinMode(ROTARY_PUSH, INPUT_PULLUP);\n  pinMode(BTN_CONFIRM, INPUT_PULLUP);\n  pinMode(BTN_BACK, INPUT_PULLUP);\n  pinMode(BUZZER_PIN, OUTPUT);\n  //digitalWrite(BUZZER_PIN, HIGH); // \u4e0d\u54cd\uff08\u4f4e\u7535\u5e73\u624d\u54cd\uff09\n  Wire.begin(OLED_SDA, OLED_SCL);\n  u8g2.begin();\n  drawMenu();\n}\n// ====== LOOP ======\nvoid loop() {\n  if (inCountdown) {\n    // \u5012\u8ba1\u65f6\u4e2d\u4ec5\u76d1\u542c\u9000\u51fa\n    if (digitalRead(BTN_BACK) == LOW) {\n      delay(200);\n      inCountdown = false;\n      drawMenu();\n    }\n    return;\n  }\n  handleRotary();\n  // \u5f00\u59cb\u5012\u8ba1\u65f6\uff08\u65cb\u94ae\u6309\u4e0b\u6216Confirm\uff09\n  if (digitalRead(ROTARY_PUSH) == LOW || digitalRead(BTN_CONFIRM) == LOW) {\n    delay(200);\n    handleSelection(menuIndex);\n    drawMenu();\n  }\n  // Back \u8fd4\u56de\u4e3b\u83dc\u5355\n  if (digitalRead(BTN_BACK) == LOW) {\n    delay(200);\n    drawMenu();\n  }\n}\n// ====== HANDLE ROTARY ======\nvoid handleRotary() {\n  int currentCLK = digitalRead(ROTARY_A);\n  if (currentCLK != lastCLK &amp;&amp; currentCLK == LOW) {\n    if (digitalRead(ROTARY_B) != currentCLK) {\n      menuIndex++;\n    } else {\n      menuIndex--;\n    }\n    if (menuIndex &lt; 1) menuIndex = 1;\n    if (menuIndex &gt; menuCount) menuIndex = menuCount;\n    drawMenu();\n  }\n  lastCLK = currentCLK;\n}\n// ====== DRAW MENU ======\nvoid drawMenu() {\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x10_tr);\n  const int visibleCount = 4;\n  int startIdx = menuIndex - 1;\n  if (startIdx &lt; 1) startIdx = 1;\n  if (startIdx &gt; menuCount - visibleCount + 1)\n    startIdx = menuCount - visibleCount + 1;\n  for (int i = 0; i &lt; visibleCount; i++) {\n    int idx = startIdx + i;\n    if (idx &gt; menuCount) break;\n    int y = i * 16 + 14;\n    if (idx == menuIndex) {\n      u8g2.drawBox(0, i * 16, 128, 16);\n      u8g2.setDrawColor(0);\n    } else {\n      u8g2.setDrawColor(1);\n    }\n    u8g2.setCursor(10, y);\n    u8g2.print(menuItems[idx - 1]);\n  }\n  u8g2.setDrawColor(1);\n  u8g2.sendBuffer();\n}\n// ====== HANDLE SELECTION ======\nvoid handleSelection(int index) {\n  if (index &gt;= 1 &amp;&amp; index &lt;= 4) {\n    int minutes[] = {10, 15, 20, 25};\n    int seconds = minutes[index - 1] * 60;\n    inCountdown = true;\n    for (int i = seconds; i &gt;= 0 &amp;&amp; inCountdown; i--) {\n      u8g2.clearBuffer();\n      u8g2.setFont(u8g2_font_logisoso32_tr);\n      int min = i / 60;\n      int sec = i % 60;\n      char timeStr[6];\n      sprintf(timeStr, \"%02d:%02d\", min, sec);\n      int textWidth = u8g2.getStrWidth(timeStr);\n      u8g2.setCursor((128 - textWidth) / 2, 45);\n      u8g2.print(timeStr);\n      u8g2.sendBuffer();\n      delay(1000);\n    }\n    if (inCountdown) {\n      flashDone();\n      beep3Times();\n    }\n    inCountdown = false;\n  } else if (index == 5) {\n    u8g2.clearBuffer();\n    u8g2.setFont(u8g2_font_6x10_tr);\n    u8g2.setCursor(10, 25);\n    u8g2.print(\"Made by Miao\");\n    u8g2.setCursor(10, 40);\n    u8g2.print(\"ESP32 Pomodoro Timer\");\n    u8g2.sendBuffer();\n    delay(3000);\n  }\n}\n// ====== BEEP FUNCTION ======\nvoid beep3Times() {\n  for (int i = 0; i &lt; 3; i++) {\n    digitalWrite(BUZZER_PIN, LOW);\n    delay(200);\n    digitalWrite(BUZZER_PIN, HIGH);\n    delay(200);\n  }\n}\n// ====== FLASH DONE ======\nvoid flashDone() {\n  for (int i = 0; i &lt; 4; i++) {\n    u8g2.clearBuffer();\n    u8g2.setFont(u8g2_font_ncenB14_tr);\n    const char* text = \"Done!\";\n    int w = u8g2.getStrWidth(text);\n    u8g2.setCursor((128 - w) / 2, 40);\n    u8g2.setDrawColor(1);\n    u8g2.print(text);\n    u8g2.sendBuffer();\n    delay(300);\n    u8g2.clearBuffer();\n    u8g2.drawBox(0, 0, 128, 64);\n    u8g2.setDrawColor(0);\n    u8g2.setCursor((128 - w) / 2, 40);\n    u8g2.print(text);\n    u8g2.sendBuffer();\n    delay(300);\n  }\n  u8g2.setDrawColor(1);\n}\n</code></pre>"},{"location":"projects/screen-project/pomodo_timer_V4/#video-demonstrations","title":"\ud83c\udfac Video Demonstrations","text":""},{"location":"projects/screen-project/pomodo_timer_V4/#13-pomodo-with-a-knob","title":"1.3' Pomodo with a knob","text":""},{"location":"projects/screen-project/system-monitor/","title":"System Monitor Display","text":"<p>Shows temperature, memory, and CPU usage from a microcontroller.</p>"},{"location":"projects/screen-project/timer/","title":"Pomodoro Timer Project","text":"<p>This project showcases a simple yet effective Pomodoro timer built with an ESP32 microcontroller and an OLED display. It features a rotary encoder for selecting duration, automatic countdown, and buzzer alerts.</p>"},{"location":"projects/screen-project/timer/#hardware-components","title":"\ud83e\uddf0 Hardware Components","text":"<ul> <li>Arduino nano development board</li> <li>1.3\" I2C OLED display embedded with EC11 encoder</li> <li>Passive buzzer module</li> <li>Breadboard + jumper wires</li> <li>3.7V Li-ion battery + switch module</li> </ul> <p>GPT Prompt for the Code: In this project, we built a Pomodoro timer using an Arduino Nano, a 1.3-inch I2C OLED display (SH1106-based), an EC11 rotary encoder with a push button, and a low-level triggered passive buzzer module.</p> <p>The timer features a scrollable menu interface, allowing users to select from the following options:</p> <p>Pomodoro 10s Pomodoro 15s Pomodoro 20s Pomodoro 25s Info</p> <p>Only four menu items are shown on screen at a time, and the encoder is used to scroll through the options. The selected menu item is highlighted with inverted colors using the U8g2 graphics library, which also handles all display rendering.</p> <p>Pressing the encoder button triggers an action:</p> <p>For Pomodoro options: A countdown begins, displayed in large digits at the center of the screen using a bold font. After the countdown ends, a \u201cDone!\u201d message flashes several times, and the passive buzzer beeps three times.</p> <p>For the \"Info\" option: A brief information page is displayed (e.g., author name and date).</p> <p>All encoder input is handled with digitalRead polling (no interrupts), and the menu scrolls smoothly within the bounds of available options. The buzzer is triggered by sending LOW signals to match its low-level activation design.</p> <p>This compact project demonstrates interactive UI handling, I2C display control, rotary encoder input, and timed output events\u2014all within the Arduino ecosystem.</p>"},{"location":"projects/screen-project/timer/#key-code-snippet","title":"\ud83e\udde0 Key Code Snippet","text":"Click to expand full code <pre><code>#include &lt;U8g2lib.h&gt;\n#include &lt;Wire.h&gt;\n\nU8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);\n\nconst int CLK = 2;\nconst int DT  = 3;\nconst int SW  = 4;\nconst int buzzerPin = 5; // Buzzer IN\n\nconst int menuCount = 5;\nconst char* menuItems[menuCount] = {\n  \"Pomodoro 10s\", \n  \"Pomodoro 15s\", \n  \"Pomodoro 20s\", \n  \"Pomodoro 25s\", \n  \"Info\"\n};\n\nint menuIndex = 1;\nint lastCLK = HIGH;\n//===========================================================\nvoid setup() {\n  pinMode(CLK, INPUT_PULLUP);\n  pinMode(DT, INPUT_PULLUP);\n  pinMode(SW, INPUT_PULLUP);\n  pinMode(buzzerPin, OUTPUT);\n  digitalWrite(buzzerPin, LOW); // initialized as LOW\n\n  u8g2.begin();\n  drawMenu();\n}\n\nvoid loop() {\n  int currentCLK = digitalRead(CLK);\n  if (currentCLK != lastCLK &amp;&amp; currentCLK == LOW) {\n    if (digitalRead(DT) != currentCLK) {\n      menuIndex++;\n    } else {\n      menuIndex--;\n    }\n    if (menuIndex &lt; 1) menuIndex = 1;\n    if (menuIndex &gt; menuCount) menuIndex = menuCount;\n    drawMenu();\n  }\n  lastCLK = currentCLK;\n\n  if (digitalRead(SW) == LOW) {\n    delay(200);\n    handleSelection(menuIndex);\n    drawMenu();\n  }\n}\n//===========================================================\nvoid drawMenu() {\n  u8g2.clearBuffer();\n  u8g2.setFont(u8g2_font_6x10_tr);\n\n  const int visibleCount = 4;\n  int startIdx = menuIndex - 1;\n  if (startIdx &lt; 1) startIdx = 1;\n  if (startIdx &gt; menuCount - visibleCount + 1)\n    startIdx = menuCount - visibleCount + 1;\n\n  for (int i = 0; i &lt; visibleCount; i++) {\n    int idx = startIdx + i;\n    if (idx &gt; menuCount) break;\n\n    int y = i * 16 + 14;\n    if (idx == menuIndex) {\n      u8g2.drawBox(0, i * 16, 128, 16);\n      u8g2.setDrawColor(0);\n    } else {\n      u8g2.setDrawColor(1);\n    }\n    u8g2.setCursor(10, y);\n    u8g2.print(menuItems[idx - 1]);\n  }\n  u8g2.setDrawColor(1);\n  u8g2.sendBuffer();\n}\n\nvoid handleSelection(int index) {\n  if (index &gt;= 1 &amp;&amp; index &lt;= 4) {\n    int seconds = 5 * index + 5;  // index=1 \u2192 10, 2 \u2192 15 ... 4 \u2192 25\n    for (int i = seconds; i &gt;= 0; i--) {\n      u8g2.clearBuffer();\n      u8g2.setFont(u8g2_font_logisoso32_tr);\n      String s = String(i);\n      int textWidth = u8g2.getStrWidth(s.c_str());\n      u8g2.setCursor((128 - textWidth) / 2, 45);\n      u8g2.print(s);\n      u8g2.sendBuffer();\n      delay(1000);\n    }\n    flashDone();\n\n  } else if (index == 5) {\n    u8g2.clearBuffer();\n    u8g2.setFont(u8g2_font_6x10_tr);\n    u8g2.setCursor(10, 25);\n    u8g2.print(\"Made by Miao\");\n    u8g2.setCursor(10, 40);\n    u8g2.print(\"2025-05-15\");\n    u8g2.sendBuffer();\n    delay(3000);\n  }\n}\n\n// flash finish\nvoid flashDone() {\n  for (int i = 0; i &lt; 4; i++) {\n    u8g2.clearBuffer();\n    u8g2.setFont(u8g2_font_ncenB14_tr);\n    String text = \"Done!\";\n    int w = u8g2.getStrWidth(text.c_str());\n    u8g2.setCursor((128 - w) / 2, 40);\n    u8g2.setDrawColor(1);\n    u8g2.print(text);\n    u8g2.sendBuffer();\n    digitalWrite(buzzerPin, HIGH); // buzzer sound\n    delay(300);\n\n    u8g2.clearBuffer();\n    u8g2.drawBox(0, 0, 128, 64);\n    u8g2.setDrawColor(0);\n    u8g2.setCursor((128 - w) / 2, 40);\n    u8g2.print(text);\n    u8g2.sendBuffer();\n    digitalWrite(buzzerPin, LOW); // buzzer sound\n    delay(300);\n  }\n  u8g2.setDrawColor(1);\n}\n</code></pre> <p>Now, once your code is running, you can replace the handleSelection function to the follow to change the Pomodo time interval.</p> Click to expand full code <pre><code>void handleSelection(int index) {\n  if (index &gt;= 1 &amp;&amp; index &lt;= 4) {\n    int minutes[] = {10, 15, 20, 25};\n    int seconds = minutes[index - 1] * 60; // This 60 is the key for unit change.\n\n    for (int i = seconds; i &gt;= 0; i--) {\n      u8g2.clearBuffer();\n      u8g2.setFont(u8g2_font_logisoso32_tr);\n\n      int min = i / 60;\n      int sec = i % 60;\n      char timeStr[6];\n      sprintf(timeStr, \"%02d:%02d\", min, sec);\n\n      int textWidth = u8g2.getStrWidth(timeStr);\n      u8g2.setCursor((128 - textWidth) / 2, 45);\n      u8g2.print(timeStr);\n      u8g2.sendBuffer();\n      delay(1000);\n    }\n    flashDone();\n    beep3Times();\n  } else if (index == 5) {\n    u8g2.clearBuffer();\n    u8g2.setFont(u8g2_font_6x10_tr);\n    u8g2.setCursor(10, 25);\n    u8g2.print(\"Made by Miao\");\n    u8g2.setCursor(10, 40);\n    u8g2.print(\"2025-05-15\");\n    u8g2.sendBuffer();\n    delay(3000);\n  }\n}\n</code></pre>"},{"location":"projects/screen-project/timer/#video-demonstrations","title":"\ud83c\udfac Video Demonstrations","text":""},{"location":"projects/screen-project/timer/#rotary-control-buzzer-feedback","title":"Rotary Control + Buzzer Feedback","text":""},{"location":"projects/screen-project/timer_091OLED/","title":"Pomodoro Timer Project","text":"<p>This project showcases a simple yet effective Pomodoro timer built with an ESP32 Supermini and an OLED display. It features a rotary encoder for time bar control, time bar shrinkage, and final alarm text.</p>"},{"location":"projects/screen-project/timer_091OLED/#hardware-components","title":"\ud83e\uddf0 Hardware Components","text":"<ul> <li>ESP32-C3 SuperMini development board</li> <li>0.91\" I2C OLED display</li> <li>EC11 rotary encoder (with button)</li> <li>Breadboard + jumper wires</li> </ul> <p>GPT Prompt for the Code: I have an ESP32-C3 SuperMini development board, a 0.91\" OLED display (128x32, I2C interface), and an EC11 rotary encoder (without a soldered push button, but can be wired).</p> <p>I want to implement a Pomodoro timer prototype using Arduino code with the following behavior:</p> <p>When rotating the EC11 encoder clockwise, the OLED screen displays a horizontal progress bar from left to right, increasing one block per tick. When rotating counterclockwise, the bar shortens from the right.</p> <p>The progress bar is made up of small vertical blocks that are 4 pixels wide, with 1 pixel spacing between each block (total 5 pixels per block). The blocks occupy the full height of the 32-pixel OLED screen.</p> <p>If there is no interaction for 2 seconds, the entire bar flashes 5 times (alternating on and off every 200 ms).</p> <p>After flashing, the timer automatically shrinks the bar from right to left, removing one block per second.</p> <p>Each block being removed flashes 3 times (i.e., 6 toggles) before it disappears, to make the countdown visually clear.</p> <p>When the progress bar is fully empty, the screen displays \u201cDone!\u201d in a large font that fills the vertical height of the screen (32 pixels) using the u8g2_font_logisoso32_tf font.</p> <p>The code uses the U8g2 graphics library for OLED display control and the Encoder library for rotary encoder input. The encoder's A and B phase pins are connected to GPIO2 and GPIO3.</p> <p>The entire behavior is in test/demo mode \u2014 each tick of the encoder corresponds to a 1-block change, and countdown occurs at 1 block per second for visualization purposes.</p>"},{"location":"projects/screen-project/timer_091OLED/#key-code-snippet","title":"\ud83e\udde0 Key Code Snippet","text":"Click to expand full code <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;U8g2lib.h&gt;\n#include &lt;Encoder.h&gt;\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 32\n#define BLOCK_WIDTH 4\n#define BLOCK_SPACING 1\n#define BLOCK_TOTAL_WIDTH (BLOCK_WIDTH + BLOCK_SPACING)\n#define MAX_BLOCKS (SCREEN_WIDTH / BLOCK_TOTAL_WIDTH)\n\n#define ENCODER_PIN_A 2\n#define ENCODER_PIN_B 3\n\nU8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0);\nEncoder knob(ENCODER_PIN_A, ENCODER_PIN_B);\n\nint numBlocks = 0;\nint lastPosition = 0;\nunsigned long lastInteraction = 0;\nbool flashing = false;\nint flashCount = 0;\nbool flashVisible = true;\nunsigned long lastFlashTime = 0;\nbool shrinking = false;\n\n// Shrinking flash for each block\nint blinkingBlockIndex = -1;\nint blinkCount = 0;\nbool blinkVisible = true;\nunsigned long lastBlinkTime = 0;\nconst int maxBlinkCount = 6;\n\nvoid drawBar(int blocks, bool visible = true, int blinkIndex = -1, bool blinkOn = true) {\n  u8g2.clearBuffer();\n\n  if (blocks == 0 &amp;&amp; !visible) {\n    u8g2.setFont(u8g2_font_logisoso32_tf);  // height 32 pixals\n    u8g2.drawStr((SCREEN_WIDTH - u8g2.getStrWidth(\"Done!\")) / 2, 32, \"Done!\");\n  } else if (visible) {\n    for (int i = 0; i &lt; blocks; i++) {\n      if (i == blinkIndex) {\n        if (blinkOn) {\n          u8g2.drawBox(i * BLOCK_TOTAL_WIDTH, 0, BLOCK_WIDTH, SCREEN_HEIGHT);\n        }\n      } else {\n        u8g2.drawBox(i * BLOCK_TOTAL_WIDTH, 0, BLOCK_WIDTH, SCREEN_HEIGHT);\n      }\n    }\n  }\n\n  u8g2.sendBuffer();\n}\n\n\nvoid setup() {\n  u8g2.begin();\n  drawBar(numBlocks);\n  lastInteraction = millis();\n}\n\nvoid loop() {\n  unsigned long now = millis();\n\n  // --- Handle Encoder ---\n  int position = knob.read() / 4;\n  if (position != lastPosition) {\n    int delta = position - lastPosition;\n    lastPosition = position;\n    numBlocks += delta;\n\n    if (numBlocks &lt; 0) numBlocks = 0;\n    if (numBlocks &gt; MAX_BLOCKS) numBlocks = MAX_BLOCKS;\n\n    drawBar(numBlocks);\n    lastInteraction = now;\n    flashing = false;\n    shrinking = false;\n    blinkingBlockIndex = -1;\n  }\n\n  // --- Flashing before shrink ---\n  if (!flashing &amp;&amp; !shrinking &amp;&amp; (now - lastInteraction &gt; 2000) &amp;&amp; numBlocks &gt; 0) {\n    flashing = true;\n    flashCount = 0;\n    flashVisible = false;\n    lastFlashTime = now;\n  }\n\n  if (flashing &amp;&amp; (now - lastFlashTime &gt; 200)) {\n    flashVisible = !flashVisible;\n    drawBar(numBlocks, flashVisible);\n    lastFlashTime = now;\n    if (!flashVisible) flashCount++;\n    if (flashCount &gt;= 5) {\n      flashing = false;\n      shrinking = true;\n      blinkingBlockIndex = -1;\n    }\n  }\n\n  // --- Shrinking with blinking ---\n  if (shrinking) {\n    if (blinkingBlockIndex == -1 &amp;&amp; numBlocks &gt; 0) {\n      blinkingBlockIndex = numBlocks - 1;\n      blinkCount = 0;\n      blinkVisible = false;\n      lastBlinkTime = now;\n    }\n\n    if (blinkingBlockIndex &gt;= 0 &amp;&amp; (now - lastBlinkTime &gt; 200)) {\n      blinkVisible = !blinkVisible;\n      lastBlinkTime = now;\n      blinkCount++;\n\n      drawBar(numBlocks, true, blinkingBlockIndex, blinkVisible);\n\n      if (blinkCount &gt;= maxBlinkCount) {\n        numBlocks--;\n        blinkingBlockIndex = -1;\n        if (numBlocks == 0) {\n          drawBar(0, false);\n          shrinking = false;\n        }\n      }\n    }\n  }\n\n  delay(10);\n}\n</code></pre>"},{"location":"projects/screen-project/timer_091OLED/#video-demonstrations","title":"\ud83c\udfac Video Demonstrations","text":""},{"location":"projects/screen-project/timer_091OLED/#version-1-basic-functionality-overview","title":"Version 1: Basic Functionality Overview","text":""},{"location":"projects/screen-project/timer_091OLED/#version-2-timer-bar-blocks-bigger-end-text","title":"Version 2: Timer Bar Blocks + Bigger End Text","text":""},{"location":"projects/screen-project/timer_091OLED_V3/","title":"Pomodoro Timer Project","text":"<p>This project showcases a simple yet effective Pomodoro timer built with an ESP32 Supermini and an OLED display. It features a rotary encoder for time bar control, time bar shrinkage, and final alarm text.</p>"},{"location":"projects/screen-project/timer_091OLED_V3/#hardware-components","title":"\ud83e\uddf0 Hardware Components","text":"<ul> <li>ESP32-C3 SuperMini development board</li> <li>0.91\" I2C OLED display</li> <li>buzzer</li> <li>WS2812 RGB LED</li> <li>EC11 rotary encoder (with button)</li> <li>Breadboard + jumper wires</li> </ul> <p>GPT Prompt for the Code: I have an ESP32-C3 SuperMini development board, a 0.91\" OLED display (128x32, I2C interface), a single EC11 rotary encoder (without a soldered button), a passive buzzer connected to GPIO1, and a single WS2812 RGB LED connected to GPIO0.</p> <p>I want to build a visual Pomodoro-style timer using Arduino. Please implement the following behavior using the U8g2 library for OLED, the Encoder library for the rotary encoder, and the Adafruit_NeoPixel library for the WS2812 LED:</p> <p>Display &amp; Timer Behavior The screen shows a horizontal progress bar composed of evenly spaced blocks.</p> <p>Each block is 8 pixels wide, with 2 pixels spacing between blocks.</p> <p>Each block has its four corners cut, like a 3-pixel right-angle triangle, removing three pixels in each corner to create a high-tech cut-corner visual effect.</p> <p>When rotating the encoder:</p> <p>Clockwise: one block is added (up to screen width);</p> <p>Counterclockwise: one block is removed from the right.</p> <p>Inactivity Response If no interaction happens for 2 seconds, the entire progress bar flashes 5 times (on/off every 200ms).</p> <p>After flashing, the progress bar automatically shrinks, one block at a time from right to left.</p> <p>Each block flashes in a \u201chalf-flash\u201d pattern before disappearing:</p> <p>Only half of the pixels inside the block are lit (checkerboard pattern);</p> <p>The block corners remain unlit during the flash, preserving the cut-corner look.</p> <p>End State When all blocks are gone:</p> <p>The screen displays \u201cDone!\u201d in large 32-pixel font (u8g2_font_logisoso32_tf), centered.</p> <p>The buzzer (GPIO1) beeps 3 times (short pulse).</p> <p>The WS2812 LED (GPIO0) is turned off.</p> <p>After 5 seconds, the display is cleared and the LED remains off.</p> <p>LED Color Feedback As the encoder rotates, the WS2812 LED cycles through hues in the RGB color wheel.</p> <p>Clockwise = forward through hues, counterclockwise = backward.</p> <p>The LED should show smooth color transitions and update in real-time with the encoder.</p> <p>Notes Use U8g2lib.h, Encoder.h, and Adafruit_NeoPixel.h.</p> <p>OLED screen should be updated efficiently.</p> <p>All visual and interactive transitions should feel responsive and smooth.</p>"},{"location":"projects/screen-project/timer_091OLED_V3/#key-code-snippet","title":"\ud83e\udde0 Key Code Snippet","text":"Click to expand full code <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;U8g2lib.h&gt;\n#include &lt;Encoder.h&gt;\n#include &lt;Adafruit_NeoPixel.h&gt;\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 32\n#define BLOCK_WIDTH 8\n#define BLOCK_SPACING 2\n#define BLOCK_TOTAL_WIDTH (BLOCK_WIDTH + BLOCK_SPACING)\n#define MAX_BLOCKS (SCREEN_WIDTH / BLOCK_TOTAL_WIDTH)\n\n#define ENCODER_PIN_A 2\n#define ENCODER_PIN_B 3\n#define BUZZER_PIN 1\n#define LED_PIN 0\n#define LED_COUNT 1\n\nU8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0);\nEncoder knob(ENCODER_PIN_A, ENCODER_PIN_B);\nAdafruit_NeoPixel pixel(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);\n\n// Status Variables\nint numBlocks = 0;\nint lastPosition = 0;\nunsigned long lastInteraction = 0;\nbool flashing = false;\nint flashCount = 0;\nbool flashVisible = true;\nunsigned long lastFlashTime = 0;\nbool shrinking = false;\n\n// Blinking Variables\nint blinkingBlockIndex = -1;\nint blinkCount = 0;\nbool blinkVisible = true;\nunsigned long lastBlinkTime = 0;\nconst int maxBlinkCount = 6;\n\n// Color Variables\nint hueValue = 0;\n\n// Finishing Screen Control\nunsigned long doneTime = 0;\nbool doneDisplayed = false;\n\n// ========================= Functions =========================\n\nvoid updateColor() {\n  pixel.setPixelColor(0, pixel.ColorHSV(hueValue * 256));\n  pixel.show();\n}\n\nvoid playBuzzer(int times) {\n  for (int i = 0; i &lt; times; i++) {\n    digitalWrite(BUZZER_PIN, HIGH);\n    delay(150);\n    digitalWrite(BUZZER_PIN, LOW);\n    delay(100);\n  }\n}\n\n// \u7ed8\u5236\u5e26\u76f4\u89d2\u4e09\u89d2\u5207\u89d2\u7684\u683c\u5b50\nvoid drawCutCornerBlock(int x, int y, int w, int h) {\n  u8g2.drawBox(x, y, w, h);\n  u8g2.setDrawColor(0); // \u6e05\u9664\u89d2\u843d\u50cf\u7d20\uff08\u4e09\u89d2\u5f62\uff09\n\n  // \u5de6\u4e0a\n  u8g2.drawPixel(x, y);\n  u8g2.drawPixel(x + 1, y);\n  u8g2.drawPixel(x, y + 1);\n\n  // \u53f3\u4e0a\n  u8g2.drawPixel(x + w - 1, y);\n  u8g2.drawPixel(x + w - 2, y);\n  u8g2.drawPixel(x + w - 1, y + 1);\n\n  // \u5de6\u4e0b\n  u8g2.drawPixel(x, y + h - 1);\n  u8g2.drawPixel(x + 1, y + h - 1);\n  u8g2.drawPixel(x, y + h - 2);\n\n  // \u53f3\u4e0b\n  u8g2.drawPixel(x + w - 1, y + h - 1);\n  u8g2.drawPixel(x + w - 2, y + h - 1);\n  u8g2.drawPixel(x + w - 1, y + h - 2);\n\n  u8g2.setDrawColor(1);\n}\n\nvoid drawBar(int blocks, bool visible = true, int blinkIndex = -1, bool blinkOn = true, bool halfFlash = false) {\n  u8g2.clearBuffer();\n\n  if (blocks == 0 &amp;&amp; !visible) {\n    u8g2.setFont(u8g2_font_logisoso32_tf);\n    u8g2.drawStr((SCREEN_WIDTH - u8g2.getStrWidth(\"Done!\")) / 2, 32, \"Done!\");\n  } else if (visible) {\n    for (int i = 0; i &lt; blocks; i++) {\n      int x = i * BLOCK_TOTAL_WIDTH;\n\n      if (i == blinkIndex &amp;&amp; !blinkOn) {\n        if (halfFlash) {\n          for (int dx = 0; dx &lt; BLOCK_WIDTH; dx++) {\n            for (int dy = 0; dy &lt; SCREEN_HEIGHT; dy++) {\n              int px = x + dx;\n\n              // \u8df3\u8fc7\u56db\u4e2a\u89d2\u843d\u7684\u4e09\u4e2a\u50cf\u7d20\uff08\u4e09\u89d2\u5f62\uff09\n              bool skipCorner =\n                (dx == 0 &amp;&amp; (dy == 0 || dy == 1 || dy == SCREEN_HEIGHT - 1 || dy == SCREEN_HEIGHT - 2)) ||\n                (dx == 1 &amp;&amp; (dy == 0 || dy == SCREEN_HEIGHT - 1)) ||\n                (dx == BLOCK_WIDTH - 1 &amp;&amp; (dy == 0 || dy == 1 || dy == SCREEN_HEIGHT - 1 || dy == SCREEN_HEIGHT - 2)) ||\n                (dx == BLOCK_WIDTH - 2 &amp;&amp; (dy == 0 || dy == SCREEN_HEIGHT - 1));\n\n              if (skipCorner) continue;\n\n              if ((dx + dy) % 2 == 0) {\n                u8g2.drawPixel(px, dy);\n              }\n            }\n          }\n\n        }\n      } else {\n        drawCutCornerBlock(x, 0, BLOCK_WIDTH, SCREEN_HEIGHT);\n      }\n    }\n  }\n\n  u8g2.sendBuffer();\n}\n\n// ========================= \u4e3b\u6d41\u7a0b =========================\n\nvoid setup() {\n  u8g2.begin();\n  pixel.begin();\n  pixel.setBrightness(80);\n  updateColor();\n\n  pinMode(BUZZER_PIN, OUTPUT);\n  digitalWrite(BUZZER_PIN, LOW);\n\n  drawBar(numBlocks);\n  lastInteraction = millis();\n}\n\nvoid loop() {\n  unsigned long now = millis();\n\n  // \u65cb\u94ae\u8f93\u5165\u5904\u7406\n  int position = knob.read() / 4;\n  if (position != lastPosition) {\n    int delta = position - lastPosition;\n    lastPosition = position;\n    numBlocks += delta;\n\n    if (numBlocks &lt; 0) numBlocks = 0;\n    if (numBlocks &gt; MAX_BLOCKS) numBlocks = MAX_BLOCKS;\n\n    // \u8272\u5f69\u6e10\u53d8\n    hueValue += delta * 5;\n    if (hueValue &lt; 0) hueValue += 256;\n    if (hueValue &gt;= 256) hueValue -= 256;\n    updateColor();\n\n    drawBar(numBlocks);\n    lastInteraction = now;\n    flashing = false;\n    shrinking = false;\n    blinkingBlockIndex = -1;\n    doneDisplayed = false;\n  }\n\n  // \u65e0\u64cd\u4f5c2\u79d2\u540e\u95ea\u70c1\u6574\u6761\n  if (!flashing &amp;&amp; !shrinking &amp;&amp; (now - lastInteraction &gt; 2000) &amp;&amp; numBlocks &gt; 0) {\n    flashing = true;\n    flashCount = 0;\n    flashVisible = false;\n    lastFlashTime = now;\n  }\n\n  if (flashing &amp;&amp; (now - lastFlashTime &gt; 200)) {\n    flashVisible = !flashVisible;\n    drawBar(numBlocks, flashVisible);\n    lastFlashTime = now;\n    if (!flashVisible) flashCount++;\n    if (flashCount &gt;= 5) {\n      flashing = false;\n      shrinking = true;\n      blinkingBlockIndex = -1;\n    }\n  }\n\n  // \u81ea\u52a8\u6d88\u51cf\uff0c\u6bcf\u5757\u95ea\u70c1\n  if (shrinking) {\n    if (blinkingBlockIndex == -1 &amp;&amp; numBlocks &gt; 0) {\n      blinkingBlockIndex = numBlocks - 1;\n      blinkCount = 0;\n      blinkVisible = false;\n      lastBlinkTime = now;\n    }\n\n    if (blinkingBlockIndex &gt;= 0 &amp;&amp; (now - lastBlinkTime &gt; 200)) {\n      blinkVisible = !blinkVisible;\n      lastBlinkTime = now;\n      blinkCount++;\n\n      drawBar(numBlocks, true, blinkingBlockIndex, blinkVisible, true);\n\n      if (blinkCount &gt;= maxBlinkCount) {\n        numBlocks--;\n        blinkingBlockIndex = -1;\n\n        if (numBlocks == 0) {\n          drawBar(0, false);\n          shrinking = false;\n          playBuzzer(3);\n          pixel.clear();\n          pixel.show();\n          doneTime = millis();\n          doneDisplayed = true;\n        }\n      }\n    }\n  }\n\n  // Done \u663e\u793a 5 \u79d2\u540e\u6e05\u7a7a\n  if (doneDisplayed &amp;&amp; millis() - doneTime &gt; 5000) {\n    u8g2.clear();\n    u8g2.sendBuffer();\n    pixel.clear();\n    pixel.show();\n    doneDisplayed = false;\n  }\n\n  delay(10);\n}\n</code></pre>"},{"location":"projects/screen-project/timer_091OLED_V3/#video-demonstrations","title":"\ud83c\udfac Video Demonstrations","text":""},{"location":"projects/screen-project/timer_091OLED_V3/#version-1-basic-functionality-overview","title":"Version 1: Basic Functionality Overview","text":""},{"location":"projects/screen-project/voice-animator/","title":"Voice-Responsive Animator","text":"<p>Visual feedback based on sound input or voice commands.</p>"},{"location":"tutorials/ai-course-basic/","title":"Getting Started with AI","text":"<p>This tutorial includes:</p> <ul> <li>How to run AI models in Colab</li> <li>Prompt engineering basics</li> <li>Practical mini-projects</li> </ul>"},{"location":"tutorials/lerobot-setup/","title":"Setting Up LeRobot","text":"<p>Steps:</p> <ol> <li>Wire servos to ESP32</li> <li>Flash firmware</li> <li>Test control signal</li> </ol>"},{"location":"tutorials/screen-howto/","title":"Building the Display Device","text":"<p>Tutorial:</p> <ol> <li>Wiring ESP32 + OLED</li> <li>Display basic text</li> <li>Add animations / sensor input</li> </ol>"}]}